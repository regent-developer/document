# 类型



## any类型

* any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。

* 变量类型一旦设为`any`，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。

**应该尽量避免使用`any`类型，否则就失去了使用 TypeScript 的意义。**

TypeScript 认为，只要开发者使用了`any`类型，就表示开发者想要自己来处理这些代码，所以就不对`any`类型进行任何限制，怎么使用都可以。 

从集合论的角度看，`any`类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。  

`any`类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。  



## unknown 类型

与`any`含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像`any`那样自由，可以视为严格版的`any`  

`unknown`跟`any`的相似之处，在于所有类型的值都可以分配给`unknown`类型。  

`unknown`类型跟`any`类型的不同之处在于，它不能直接使用。主要有以下几个限制:

* `unknown`类型的变量，不能直接赋值给其他类型的变量（除了`any`类型和`unknown`类型）
* 不能直接调用`unknown`类型变量的方法和属性
* `unknown`类型变量能够进行的运算是有限的，只能进行比较运算（运算符`==`、`===`、`!=`、`!==`、`||`、`&&`、`?`）、取反运算（运算符`!`）、`typeof`运算符和`instanceof`运算符这几种，其他运算都会报错

如使用unknown变量，需使用类型缩小，所谓类型缩小就是缩小`unknown`变量的类型范围，确保不会出错。

```typescript
let a:unknown = 1;

if (typeof a === 'number') {
  let r = a + 10; // 正确
}
```

**一般来说，凡是需要设为`any`类型的地方，通常都应该优先考虑设为`unknown`类型。**



在集合论上，`unknown`也可以视为所有其他类型（除了`any`）的全集，所以它和`any`一样，也属于 TypeScript 的顶层类型。



## never 类型

该类型为空，不包含任何值。  

`never`类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性 ，不可能返回值的函数，返回值的类型就可以写成`never`。

**`never`类型的一个重要特点是，可以赋值给任意其他类型。**

